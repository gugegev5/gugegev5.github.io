function(e, t) {
    e.exports = "#define GLSLIFY 1\n#define SHADER_NAME BACKGROUND\n// #pragma glslify: snoise2 = require(glsl-noise/simplex/2d)\n\nvarying vec2 vUv;\nuniform float uTime;\nuniform float uZoom;\nuniform float uMixBoost;\nuniform float uDisplacement;\nuniform float uBaseDistortion;\nuniform float uMaxDistortion;\nuniform float uDistortion;\nuniform float uStep;\nuniform vec2 uScreen;\nuniform vec2 uMouse;\nuniform vec2 uTextSize;\nuniform vec2 uUvOfsset;\nuniform vec2 uSpeed;\nuniform vec2 uMixRange;\n\nuniform sampler2D uMap0;\nuniform sampler2D uMap1;\nuniform sampler2D uMap2;\nuniform sampler2D uMap3;\nuniform sampler2D uMap4;\nuniform sampler2D uMap5;\n\nuniform float uMapOffset0;\nuniform float uMapOffset1;\nuniform float uMapOffset2;\nuniform float uMapOffset3;\nuniform float uMapOffset4;\nuniform float uMapOffset5;\nuniform float uMapOffsetC;\nuniform float uMapOffsetCL;\nuniform float uMapOffsetCR;\n\nfloat random (in vec2 _st) {\n  return fract(sin(dot(_st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 1\n\nfloat fbm (in vec2 _st) {\n  float v = 0.0;\n  float a = 0.5;\n  vec2 shift = vec2(100.0);\n  // Rotate to reduce axial bias\n  mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n  for (int i = 0; i < NUM_OCTAVES; ++i) {\n      v += a * noise(_st);\n      _st = rot * _st * 2.0 + shift;\n      a *= 0.5;\n  }\n  return v;\n}\n\nvoid main() {\n  vec2 st = (vUv + uUvOfsset * .1) * uZoom;\n  vec3 color = vec3(0.0);\n\n  vec2 r = vec2(0.);\n  r.x = fbm(st + 1.0 + vec2(1.7,9.2)+ 0.15 * uTime * .0001 * uSpeed.x);\n  r.y = fbm(st + 1.0 + vec2(8.3,2.8)+ 0.126 * uTime * .0001 * uSpeed.y);\n\n  float f = fbm(st + r );\n\n  color = mix(vec3(uMixRange.x), vec3(uMixRange.y), clamp( ( f * f ) * uMixBoost, 0.0, 1.0));\n\n  // invert\n  color = 1. - color;\n\n  // fbm magic\n  color = f * color;\n\n  vec2 stR = uScreen / uTextSize;\n\n  float m = max( stR.x, stR.y );\n\n  vec2 uv = vec2(vUv.x, vUv.y);\n  uv -= vec2(.5);\n  uv *= stR;\n  uv *= 1. / m;\n  uv += vec2(.5);\n\n  float yCenterProgress = exp(vUv.y - .5) * uMaxDistortion * -uDistortion;\n  float dist = min((1. - distance(vUv, uMouse)) / 2., 1.);\n\n  float d = (color.r * 1.- .05) * ( dist * 4.5 * uDistortion + uBaseDistortion);\n  uv.x += yCenterProgress;\n  uv.x += uDisplacement;\n\n  vec4 texel0 = texture2D(uMap0, vec2(uv.x + d, uv.y));\n  texel0.a = step(0., uv.x) * (1. - step(1., uv.x));\n\n  vec4 texel1 = texture2D(uMap1, vec2(uv.x  + d + uMapOffset1, uv.y));\n  texel1.a = step(0., uv.x + uMapOffset1) * (1. - step(1., uv.x + uMapOffset1));\n\n  vec4 texel2 = texture2D(uMap2, vec2(uv.x  + d + uMapOffset2, uv.y));\n  texel2.a = step(0., uv.x + uMapOffset2) * (1. - step(1., uv.x  + uMapOffset2));\n\n  vec4 texel3 = texture2D(uMap3, vec2(uv.x  + d + uMapOffset3, uv.y));\n  texel3.a = step(0., uv.x  + uMapOffset3) * (1. - step(1., uv.x + uMapOffset3));\n\n  vec4 texel4 = texture2D(uMap4, vec2(uv.x  + d + uMapOffset4, uv.y));\n  texel4.a = step(0., uv.x + uMapOffset4) * (1. - step(1., uv.x + uMapOffset4));\n\n  vec4 texel5 = texture2D(uMap5, vec2(uv.x  + d + uMapOffset5, uv.y));\n  texel5.a = step(0., uv.x + uMapOffset5) * (1. - step(1., uv.x + uMapOffset5));\n\n  vec4 texelC = texture2D(uMap0, vec2(uv.x  + d + uMapOffsetC, uv.y));\n  texelC.a = step(0., uv.x + uMapOffsetC) * (1. - step(1., uv.x + uMapOffsetC));\n\n  vec4 texelCL = texture2D(uMap5, vec2(uv.x  + d + uMapOffsetCL + 1., uv.y));\n  texelCL.a = step(0., uv.x + uMapOffsetCL) * (1. - step(1., uv.x + uMapOffsetCL));\n\n  vec4 texelCR = texture2D(uMap1, vec2(uv.x  + d + uMapOffsetCR, uv.y));\n  texelCR.a = step(0., uv.x + uMapOffsetCR) * (1. - step(1., uv.x + uMapOffsetCR));\n\n  gl_FragColor =\n    texel0 * texel0.a +\n    texel1 * texel1.a +\n    texel2* texel2.a +\n    texel3 * texel3.a +\n    texel4 * texel4.a +\n    texel5 * texel5.a +\n    texelC * texelC.a +\n    texelCR * texelCR.a +\n    texelCL * texelCL.a;\n\n  gl_FragColor = mix(gl_FragColor, vec4(1., 1., 1., 1.), step(vUv.y, uStep));\n}\n"
}